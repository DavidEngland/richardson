<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MOST Stability Tool (Standalone)</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css">
  <!-- D3.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    .chart-container { margin: 1rem 0; }
    .chart-title { font-weight: 600; margin: 0.5rem 0; }
    .legend { font: 12px sans-serif; }
    .legend rect { stroke: #ccc; fill: none; }
    .axis-label { font: 12px sans-serif; }
    svg { max-width: 100%; height: auto; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
</head>
<body>
  <h1>MOST Stability Tool (Standalone)</h1>

  <section>
    <label>Profile
      <select id="profile">
        <option value="BD71">Businger-Dyer 1971</option>
        <option value="HOG88">Högström 1988</option>
        <option value="CB05">Cheng-Brutsaert 2005</option>
      </select>
    </label>

    <label>Regime
      <select id="regime">
        <option value="full">Full (-10 to 10)</option>
        <option value="unstable">Unstable (-10 to 0)</option>
        <option value="stable">Stable (0 to 10)</option>
      </select>
    </label>

    <button id="refresh">Refresh Charts</button>
    <button id="csv">Export CSV</button>
  </section>

  <section>
    <h3>Parameter Conversion</h3>
    <label>Conversion
      <select id="mode">
        <option value="rig_to_zeta">Ri_g → ζ (and Ri_b)</option>
        <option value="rib_to_zeta">Ri_b → ζ (and Ri_g)</option>
        <option value="zeta_to_all">ζ → All</option>
      </select>
    </label>
    <label>Input
      <input id="input" type="number" step="0.001" value="0.1"/>
    </label>
    <button id="convert">Convert</button>
    <pre id="output" class="mono"></pre>
  </section>

  <div class="chart-container">
    <div class="chart-title">ζ vs Richardson Numbers</div>
    <div id="chart_richardson"></div>
  </div>

  <div class="chart-container">
    <div class="chart-title">ζ vs Stability Functions φ</div>
    <div id="chart_phi"></div>
  </div>

  <script>
    // Physics and numerics
    const profiles = {
      BD71: { unstable: { am:16, ah:16, bm:0.25, bh:0.5 }, stable: { bm:5, bh:5 } },
      HOG88:{ unstable: { am:19.3, ah:11.6, bm:0.25, bh=0.5 }, stable: { bm=6, bh=7.8 } },
      CB05: { unstable: { am=16, ah=16, bm=0.25, bh=0.5 }, stable: { bm=6.1, bh=6.1, cm=5.3, ch=5.3 } }
    };
    const NUM = { PSI_STEPS:100, SINGULAR:1e-10, DZ:1e-8, BOUNDS:[-10, 10] };
    const SURFACE = { Z_OVER_Z0: 1000 }; // ln(z/z0) term for Ri_b

    const phi_m = (z, p) => {
      const prof = profiles[p];
      if (z < 0) return Math.pow(1 - prof.unstable.am * z, -prof.unstable.bm);
      return p === 'CB05' ? 1 + prof.stable.bm * z + (prof.stable.cm || 0) * z * z : 1 + prof.stable.bm * z;
    };
    const phi_h = (z, p) => {
      const prof = profiles[p];
      if (z < 0) return Math.pow(1 - prof.unstable.ah * z, -prof.unstable.bh);
      return p === 'CB05' ? 1 + prof.stable.bh * z + (prof.stable.ch || 0) * z * z : 1 + prof.stable.bh * z;
    };
    const psi_m = (z, p) => {
      if (Math.abs(z) < NUM.SINGULAR) return 0;
      const prof = profiles[p];
      if (z < 0) {
        const x = Math.pow(1 - prof.unstable.am * z, 0.25);
        return 2 * Math.log((1 + x) / 2) + Math.log((1 + x * x) / 2) - 2 * Math.atan(x) + Math.PI / 2;
      }
      const steps = NUM.PSI_STEPS, dz = z / steps; let sum = 0;
      for (let i = 1; i <= steps; i++) { const zi = i * dz; sum += (1 / phi_m(zi, p) - 1) * dz; }
      return sum;
    };
    const psi_h = (z, p) => {
      if (Math.abs(z) < NUM.SINGULAR) return 0;
      const prof = profiles[p];
      if (z < 0) { const y = Math.pow(1 - prof.unstable.ah * z, 0.5); return 2 * Math.log((1 + y) / 2); }
      const steps = NUM.PSI_STEPS, dz = z / steps; let sum = 0;
      for (let i = 1; i <= steps; i++) { const zi = i * dz; sum += (1 / phi_h(zi, p) - 1) * dz; }
      return sum;
    };
    const ri_g = (z, p) => { const pm = phi_m(z, p), ph = phi_h(z, p); return z * ph / (pm * pm); };
    const ri_b = (z, p) => {
      if (Math.abs(z) < NUM.SINGULAR) return 0;
      const lnz = Math.log(SURFACE.Z_OVER_Z0);
      if (!(lnz > 0)) return 0;
      const psim = psi_m(z, p), psih = psi_h(z, p);
      const denom = Math.pow(lnz - psim, 2);
      return denom < 1e-15 ? 0 : z * (lnz - psih) / denom;
    };
    const zeta_from_rig = (rig, p, guess = 0.1) => {
      let z = guess;
      for (let i = 0; i < 100; i++) {
        const f = ri_g(z, p) - rig;
        if (Math.abs(f) < 1e-10) return z;
        const df = (ri_g(z + NUM.DZ, p) - ri_g(z - NUM.DZ, p)) / (2 * NUM.DZ);
        if (Math.abs(df) < 1e-15) break;
        z = Math.max(NUM.BOUNDS[0], Math.min(NUM.BOUNDS[1], z - f / df));
      }
      return z;
    };
    const zeta_from_rib = (rib, p, guess = 0.1) => {
      let z = guess;
      for (let i = 0; i < 100; i++) {
        if (Math.abs(z) < NUM.SINGULAR) z = NUM.SINGULAR;
        const f = ri_b(z, p) - rib;
        if (Math.abs(f) < 1e-10) return z;
        const df = (ri_b(z + NUM.DZ, p) - ri_b(z - NUM.DZ, p)) / (2 * NUM.DZ);
        if (Math.abs(df) < 1e-15) break;
        z = Math.max(NUM.BOUNDS[0], Math.min(NUM.BOUNDS[1], z - f / df));
      }
      return z;
    };

    // Reference data
    function generateReferenceData(profile, regime) {
      let zetaRange = [];
      if (regime === 'unstable') zetaRange = d3.range(-10, 0.0001, 0.1);
      else if (regime === 'stable') zetaRange = d3.range(0, 10.0001, 0.1);
      else zetaRange = d3.range(-10, 10.0001, 0.1);

      return zetaRange.map(z => {
        const pm = phi_m(z, profile);
        const ph = phi_h(z, profile);
        const rig = ri_g(z, profile);
        const rib = Math.abs(z) > 1e-5 ? ri_b(z, profile) : 0;
        return {
          zeta: +z.toFixed(4),
          phi_m: +pm.toFixed(4),
          phi_h: +ph.toFixed(4),
          Ri_g: +rig.toFixed(4),
          Ri_b: +rib.toFixed(4)
        };
      });
    }

    // Simple multi-series D3 line chart
    function drawLineChart(containerId, data, series, xLabel, yLabel) {
      const container = d3.select(containerId);
      container.selectAll('*').remove();

      const width = Math.min(700, container.node().clientWidth || 700);
      const height = 300;
      const margin = { top: 20, right: 20, bottom: 45, left: 60 };

      const svg = container.append('svg')
        .attr('viewBox', `0 0 ${width} ${height}`);

      const x = d3.scaleLinear()
        .domain(d3.extent(data, d => d.zeta)).nice()
        .range([margin.left, width - margin.right]);

      // Compute y domain across all series
      const allY = [];
      series.forEach(s => data.forEach(d => {
        const v = d[s.key];
        if (Number.isFinite(v)) allY.push(v);
      }));
      const y = d3.scaleLinear()
        .domain(d3.extent(allY)).nice()
        .range([height - margin.bottom, margin.top]);

      const xAxis = g => g
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(x))
        .call(g => g.append('text')
          .attr('class', 'axis-label')
          .attr('x', (width - margin.left - margin.right) / 2 + margin.left)
          .attr('y', 35)
          .attr('fill', 'currentColor')
          .attr('text-anchor', 'middle')
          .text(xLabel));

      const yAxis = g => g
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(y))
        .call(g => g.append('text')
          .attr('class', 'axis-label')
          .attr('x', - (height - margin.top - margin.bottom) / 2)
          .attr('y', -45)
          .attr('transform', 'rotate(-90)')
          .attr('fill', 'currentColor')
          .attr('text-anchor', 'middle')
          .text(yLabel));

      svg.append('g').call(xAxis);
      svg.append('g').call(yAxis);

      const line = d3.line()
        .defined(d => Number.isFinite(d.value))
        .x(d => x(d.zeta))
        .y(d => y(d.value));

      series.forEach(s => {
        const seriesData = data.map(d => ({ zeta: d.zeta, value: d[s.key] }));
        svg.append('path')
          .datum(seriesData)
          .attr('fill', 'none')
          .attr('stroke', s.color)
          .attr('stroke-width', 1.5)
          .attr('d', line);
      });

      // Legend
      const legend = svg.append('g').attr('class', 'legend')
        .attr('transform', `translate(${width - margin.right - 120}, ${margin.top})`);
      series.forEach((s, i) => {
        const g = legend.append('g').attr('transform', `translate(0, ${i * 18})`);
        g.append('rect').attr('width', 12).attr('height', 12).attr('fill', s.color);
        g.append('text').attr('x', 16).attr('y', 10).text(s.label);
      });
    }

    // CSV export
    function exportCSV(rows) {
      const headers = ['zeta', 'phi_m', 'phi_h', 'Ri_g', 'Ri_b'];
      const csv = [
        headers.join(','),
        ...rows.map(r => headers.map(h => r[h]).join(','))
      ].join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'MOST_reference.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Wire UI
    const els = {
      profile: document.getElementById('profile'),
      regime: document.getElementById('regime'),
      mode: document.getElementById('mode'),
      input: document.getElementById('input'),
      output: document.getElementById('output'),
      refresh: document.getElementById('refresh'),
      csv: document.getElementById('csv'),
      convert: document.getElementById('convert')
    };

    let currentData = [];

    function render() {
      const prof = els.profile.value;
      const reg = els.regime.value;
      currentData = generateReferenceData(prof, reg);

      drawLineChart('#chart_richardson', currentData, [
        { key: 'Ri_g', color: '#8884d8', label: 'Ri_g' },
        { key: 'Ri_b', color: '#82ca9d', label: 'Ri_b' }
      ], 'ζ = z/L', 'Richardson Number');

      drawLineChart('#chart_phi', currentData, [
        { key: 'phi_m', color: '#ff7300', label: 'φ_m' },
        { key: 'phi_h', color: '#d84aff', label: 'φ_h' }
      ], 'ζ = z/L', 'φ');
    }

    els.refresh.onclick = render;
    els.profile.onchange = render;
    els.regime.onchange = render;

    els.csv.onclick = () => exportCSV(currentData);

    els.convert.onclick = () => {
      const prof = els.profile.value;
      const mode = els.mode.value;
      const val = parseFloat(els.input.value);
      if (Number.isNaN(val)) { els.output.textContent = 'Invalid input'; return; }

      let z, out;
      try {
        if (mode === 'rig_to_zeta') {
          z = zeta_from_rig(val, prof, val > 0 ? 0.1 : -0.1);
          out = { zeta: z, Ri_g: ri_g(z, prof), Ri_b: ri_b(z, prof), phi_m: phi_m(z, prof), phi_h: phi_h(z, prof) };
        } else if (mode === 'rib_to_zeta') {
          z = zeta_from_rib(val, prof, val > 0 ? 0.1 : -0.1);
          out = { zeta: z, Ri_g: ri_g(z, prof), Ri_b: ri_b(z, prof), phi_m: phi_m(z, prof), phi_h: phi_h(z, prof) };
        } else {
          z = val;
          out = { zeta: z, Ri_g: ri_g(z, prof), Ri_b: ri_b(z, prof), phi_m: phi_m(z, prof), phi_h: phi_h(z, prof) };
        }
        els.output.textContent = JSON.stringify(out, null, 2);
      } catch (e) {
        els.output.textContent = 'Conversion failed';
      }
    };

    // Initial render
    render();
  </script>
</body>
</html>
